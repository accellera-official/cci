Guidelines to be required in the standard

----------------------------------------------------------------

BASIC STRUCTURE

A CCI system consists of the following parts:
- CCI standard header files
- One broker implementation
- One standard parameter implementation
- Potentially additional parameter type implementations
- The user code

----------------------------------------------------------------

CCI STANDARD HEADER FILES

OSCI header files are provided by the include file cci.h
They contain all code needed by user models to write and compile vendor
independent models.
As well the headers are the glue between broker implementation, parameter 
implementation and user model, all being able to be compiled on their own 
and linked together.

All three independent participants (models, parameter implementations, broker
implementations) shall not include each other but only use the cci.h file.

Additional parameter implementation headers shall not be included by the
model or the broker implementation.

Broker implementation headers shall not be included by the model or any
parameter implementation.

----------------------------------------------------------------

BROKER IMPLEMENTATION (TOOL VENDOR)

The library implementing the CCI configuration broker must provide the 
following global functions, declared in file cci_config.h. 
TODO: They shall be available no later than the start of elaboration (e.g. sc_main).
  much earlier!!

  get_cnf_broker_instance(sc_object*)
  get_cnf_broker_instance(const string&)

----------------------------------------------------------------

PARAMETER IMPLEMENTATION

The library implementing the CCI configuration parameters must provide the 
following global functions, declared in the file cci_config.h.

  create_cci_param 
  init_cci_param
  destroy_cci_param


The one standard parameter implementation (library) shall provide the 
following symbols:
- the parameter functions above for (only!) the standard parameter types
- the cci_value implementation for class cci_value in file cci_value.h
Drawback: Such a library might be quite large (e.g. 700 MB in the prototype) due to the 
          symbols of sc_(big)(u)int<width> for all width 
          from 1 to 64 or 1 to e.g. 1024
Workaround within a tool environment:
          Use a Makefile which searches for undefined symbols of the needed 
          parameter factory functions, create and compile a cpp which creates
          exactly those symbols and link afterwards.
          see Makefile.only.needed.symbols in dev_examples/gs_example
          use: make -f Makefile.only.needed.symbols

Potentially additional parameter implementation libraries (or object files) 
shall provide symbols for only one additional parameter type (or a set of
strongly related types).

Thus it is possible to choose one vendor for the standard types and use other 
vendors for additional types.

----------------------------------------------------------------

STANDARD PARAMETER TYPES

Currently proposed data types to be provided by the parameter library:
  int
  unsigned int
  bool
  double
  float
  std::string
  long long
  unsigned char
  signed char
  char
  unsigned short
  std::vector<std::string>
  sc_dt::sc_int_base
  sc_dt::sc_uint_base
  sc_dt::sc_signed
  sc_dt::sc_unsigned
  sc_dt::sc_bit
  sc_dt::sc_logic
  sc_core::sc_time
  sc_dt::sc_int<w> w=1...64
  sc_dt::sc_uint<w> w=1...64
  sc_dt::sc_bigint<w> w=1...1024
  sc_dt::sc_biguint<w> w=1...1024

Any sc_big(u)int with bit width larger than 1024 had to be provided 
by additional parameter implementation (library).

TODO: Check types with C++ standard

----------------------------------------------------------------

JSON STUFF

Uninitialized and invalid:
 Representation for param status uninitialized and invalid: 
 JSON value: null (not the string "null")

sc_time:
 Represenatation for sc_time values:
 as a JSON string: "10 SC_NS"
 The string shall begin with a JSON double number string followed
 by a space and followed by an sc_time_unit string represenation 
 ("SC_FS", "SC_PS", "SC_NS", "SC_US", "SC_MS", "SC_SEC"). 
 The sc_time_unit string shall be not case sensitiv.

----------------------------------------------------------------

CALLBACKS

In general for all callbacks it is still TODO to define when exactly 
(on which interface/function call) which callback has to be called.
(e.g. a list: on base param function xy, call cb abc)


----------------------------------------------------------------

REJECT_WRITE CALLBACK 
and
PRE_WRITE CALLBACK

Any reject_write callback is allowed to reject the value (by returning
the according enum item). Thus each observer getting such a callback must
not rely on the given value to appear as the new one - use pre_write instead!

If the value change is rejected (during reject_write), there will be no 
pre_write and no post_write callbacks for this change. If a reject_write
callback rejects the value, all remaining reject_write callbacks shall
still be called.

A pre_write callback must not reject the value write.


----------------------------------------------------------------

CALLBACK ORDER

The callback order must match the registration order. This allows the 
tool to register all desired callbacks prior to all others, because it 
gets the add_param() call at parameter construction.

Note:
This also allows to lock a parameter just on its creation on the highest
hierarchical level, to allow OVM-like precedence (because the highest 
level is able to register for new param callbacks before the lower ones).
(This is true for all callbacks being registered with the same broker,
which is usually the case, private brokers hide private params anyway.)


----------------------------------------------------------------

CALLBACK RETURN STATUS

The parameter implementation shall evaluate the enum returned by callback
functions and perform the according action (e.g. reject a value and throw
a set_param_failed exception).


----------------------------------------------------------------

STRING REPRESENTATION

Parameter string representations are JSON-conform (see http://www.json.org/)
Examples:
 Numbers:
  42
  42.3333
  -42.23e+12
 Strings:
  "Any unicode character but some specials like \" \\ \/"
 bool:
  true
  false
 Objects:
  {"any string":{"any object":42,"another member":43}}


----------------------------------------------------------------

ERROR/WARNING/INFO THROWING

The implementation shall throw sc_reports to report problems (warning/error)
or status (info). The id prefix should be (TODO:) "/OSCI/CCI/" followed by
one of the types defined in cci_error_types.h.


----------------------------------------------------------------

HOW TO GET ACCESS TO BROKERS

Any instance that accesses any CCI configuration feature shall get access to 
its broker and any foreign parameters only by calling  the global 
get_cnf_broker_instance function. (Parameter objects owned by this instance 
shall be created as described elsewhere instantiating the parameter objects.) 
It is recommended to keep the returned pointer due to performance reasons. 
Any CCI parameter but the own ones shall be accessed only through this broker 
and not using separate ways, like e.g. using the child parameter object 
directly. This is to make sure the broker can add the correct originator 
information for debug pupose on parameter accesses.


----------------------------------------------------------------

PARAMETER ACCESSORS

While a configurable module creates configuration parameters (cci_param) directly
- I call this original parameter for now -, configurators get access to those 
parameters through brokers (compare section HOW TO GET ACCESS TO BROKERS). 
The broker does not return the original parameter object (which the owning module 
instantiated) but returns a parameter accessor.

The broker (which is specific for each originator, cp. broker_accessor, in the POC-
implementation) shall create, return and manage one parameter accessor per original 
parameter and originator. This parameter accessor can be created using the 
cci_(base_)param create_accessor-function. Internally all parameter objects point to
the same parameter implementation.

The difference between the original parameter object and the parameter accessor 
object is that the parameter accessor forwards its originator information, which is
internally stored, to all function calls that are forwared to the underlying 
implementation (cci_(base_)param_impl_if).


----------------------------------------------------------------

ORIGINATOR INFORMATION FLOW

Originator information means that for some actions on parameters it is possible to ask 
for the responsible originator of that change or action in general. The end user has 
two places where he encounters the originator information: 
1/ When asking for the responsible broker it is important to give the originator 
   information to the global get function. This is either (recommended) the sc_object-
   pointer of the instance that asks for the broker, or - if no sc_object pointer is 
   available - a string that is realated or suitable to identify the object. This 
   information is internally attached to the broker which forwards it on all action 
   performed on that broker. The broker also attaches the information to all parameters 
   that are requested over this broker: parameter accessors instead of the original 
   parameter are returned to the end user.
2/ Each time an action happens which allows to ask for the originator - e.g. a 
   parameter callback happens - the parameter object (original parameter or parameter 
   accessor) can be asked for the originator. Example: Within a post_write-Callback on 
   the given parameter the function get_originator returns the originator.

Internally the originator information flow is following:
(POC-Implementation:) The user gives the originator (object or string) to the global 
function get_cnf_broker_instance. There one broker accessor per originator is created, 
all using one originator-independent broker in the background. The broker accessors 
store the originator information. Each time the broker accessor is asked to do some 
action it forwards the originator information to the background broker function it calls. 
In the case it shall return a parameter object to the user it creates one parameter 
accessor object per original parameter (it holds a map of all created param accessors). 
(Std. Header:) The parameter accessors get the originator information during construction 
- which happens using the create_accessor-function on the cci_(base_)param. Each time the 
parameter accessor is used by the configurator (who asked for it), the accessor forwards 
the originator (object or string) to the underlying implementation 
(cci_(base_)param_impl_if).
(POC-Implementation:) The parameter implementation now needs to make sure the originator 
information is available via the get_orginator calls during and after the specific action, 
e.g. callback.

TODO: are there needs for a get_originator other than on parameter objects? If yes, where?


----------------------------------------------------------------

--
Christian Schr√∂der
christian.schroeder@greensocs.com
