// The following is an exact copy of
//  #include "greenbus/utils/shared_ptr.h"

#ifndef GS_SHARED_PTR_H_INCLUDED
#define GS_SHARED_PTR_H_INCLUDED

/*
 Boost Software License - Version 1.0 - August 17th, 2003
 
 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so, all subject to the following:
 
 The copyright notices in the Software and this entire statement, including
 the above license grant, this restriction and the following disclaimer,
 must be included in all copies of the Software, in whole or in part, and
 all derivative works of the Software, unless such copies or derivative
 works are solely in the form of machine-executable object code generated by
 a source language processor.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
 */

/*
 This implementation is based on the shared_ptr implementation of the boost library 1_33_1:
 
 //
 //  shared_ptr.hpp
 //
 //  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
 //  Copyright (c) 2001, 2002, 2003 Peter Dimov
 //
 
 It basically adds a new constructor and cast function to the boost::shared_ptr of 
 boost release 1_33_1.
 This addition could not be achieved deriving from boost::shared_ptr, since the
 members px and pn are private.
 */

// DONOTRELICENSE

#include <boost/config.hpp>   // for broken compiler workarounds

#if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
#include <boost/detail/shared_ptr_nmt.hpp>
#else

#include <boost/assert.hpp>
#include <boost/checked_delete.hpp>
#include <boost/throw_exception.hpp>
#include <boost/detail/shared_count.hpp>
#include <boost/detail/workaround.hpp>
#include <boost/enable_shared_from_this.hpp>

#include <memory>               // for std::auto_ptr
#include <algorithm>            // for std::swap
#include <functional>           // for std::less
#include <typeinfo>             // for std::bad_cast
#include <iosfwd>               // for std::basic_ostream

#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
# pragma warning(push)
# pragma warning(disable:4284) // odd return type for operator->
#endif

namespace boost{
  template<class T> class enable_shared_from_this;
}

namespace gs
{
  
  namespace detail
  {
    
    struct static_cast_tag {};
    struct const_cast_tag {};
    struct dynamic_cast_tag {};
    struct polymorphic_cast_tag {};
    struct access_down_cast_tag {};   //added
    
    template<class T> struct shared_ptr_traits
    {
      typedef T & reference;
    };
    
    template<> struct shared_ptr_traits<void>
    {
      typedef void reference;
    };
    
#if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
    
    template<> struct shared_ptr_traits<void const>
    {
      typedef void reference;
    };
    
    template<> struct shared_ptr_traits<void volatile>
    {
      typedef void reference;
    };
    
    template<> struct shared_ptr_traits<void const volatile>
    {
      typedef void reference;
    };
    
#endif
    
    // enable_shared_from_this support
    
    template<class T, class Y> void sp_enable_shared_from_this( ::boost::detail::shared_count const & pn, ::boost::enable_shared_from_this<T> const * pe, Y const * px )
    {
      if(pe != 0) pe->_internal_weak_this._internal_assign(const_cast<Y*>(px), pn);
    }
    
    inline void sp_enable_shared_from_this( ::boost::detail::shared_count const & /*pn*/, ... )
    {
    }
    
  } // namespace detail
  
  
  //
  //  shared_ptr
  //
  //  An enhanced relative of scoped_ptr with reference counted copy semantics.
  //  The object pointed to is deleted when the last shared_ptr pointing to it
  //  is destroyed or reset.
  //
  
  template<class T> class shared_ptr
    {
    private:
      
      // Borland 5.5.1 specific workaround
      typedef shared_ptr<T> this_type;
      
    public:
      
      typedef T element_type;
      typedef T value_type;
      typedef T * pointer;
      typedef typename detail::shared_ptr_traits<T>::reference reference;
      
      shared_ptr(): px(0), pn() // never throws in 1.30+
      {
      }
      
      template<class Y>
      explicit shared_ptr( Y * p ): px( p ), pn( p ) // Y must be complete
      {
        detail::sp_enable_shared_from_this( pn, p, p );
      }
      
      //
      // Requirements: D's copy constructor must not throw
      //
      // shared_ptr will release p by calling d(p)
      //
      
      template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
      {
        detail::sp_enable_shared_from_this( pn, p, p );
      }
      
      //  generated copy constructor, assignment, destructor are fine...
      
      //  except that Borland C++ has a bug, and g++ with -Wsynth warns
#if defined(__BORLANDC__) || defined(__GNUC__)
      
      shared_ptr & operator=(shared_ptr const & r) // never throws
      {
        px = r.px;
        pn = r.pn; // shared_count::op= doesn't throw
        return *this;
      }
      
#endif
      
      template<class Y>
      shared_ptr(shared_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
      {
      }
      
      template<class Y>
      shared_ptr(shared_ptr<Y> const & r, detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
      {
      }
      
      template<class Y>
      shared_ptr(shared_ptr<Y> const & r, detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
      {
      }
      
      template<class Y>
      shared_ptr(shared_ptr<Y> const & r, detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
      {
        if(px == 0) // need to allocate new counter -- the cast failed
        {
          pn = ::boost::detail::shared_count();
        }
      }
      
      template<class Y>
      shared_ptr(shared_ptr<Y> const & r, detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
      {
        if(px == 0)
        {
          boost::throw_exception(std::bad_cast());
        }
      }
      
      
      template<class Y>
      shared_ptr(shared_ptr<Y> const & r, detail::access_down_cast_tag): px(r.px->getSuperClassPtr()), pn(r.pn)
      {
      }
      
#ifndef BOOST_NO_AUTO_PTR
      
      template<class Y>
      explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
      {
        Y * tmp = r.get();
        pn = ::boost::detail::shared_count(r);
        detail::sp_enable_shared_from_this( pn, tmp, tmp );
      }
      
#endif
      
#if !defined(BOOST_MSVC) || (BOOST_MSVC > 1200)
      
      template<class Y>
      shared_ptr & operator=(shared_ptr<Y> const & r) // never throws
      {
        px = r.px;
        pn = r.pn; // shared_count::op= doesn't throw
        return *this;
      }
      
#endif
      
#ifndef BOOST_NO_AUTO_PTR
      
      template<class Y>
      shared_ptr & operator=(std::auto_ptr<Y> & r)
      {
        this_type(r).swap(*this);
        return *this;
      }
      
#endif
      
      void reset() // never throws in 1.30+
      {
        this_type().swap(*this);
      }
      
      template<class Y> void reset(Y * p) // Y must be complete
      {
        BOOST_ASSERT(p == 0 || p != px); // catch self-reset errors
        this_type(p).swap(*this);
      }
      
      template<class Y, class D> void reset(Y * p, D d)
      {
        this_type(p, d).swap(*this);
      }
      
      reference operator* () const // never throws
      {
        BOOST_ASSERT(px != 0);
        return *px;
      }
      
      T * operator-> () const // never throws
      {
        BOOST_ASSERT(px != 0);
        return px;
      }
      
      T * get() const // never throws
      {
        return px;
      }
      
      // implicit conversion to "bool"
      
#if defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, <= 0x530)
      
      operator bool () const
      {
        return px != 0;
      }
      
#elif \
( defined(__MWERKS__) && BOOST_WORKAROUND(__MWERKS__, < 0x3200) ) || \
( defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ < 304) )
      
      typedef T * (this_type::*unspecified_bool_type)() const;
      
      operator unspecified_bool_type() const // never throws
      {
        return px == 0? 0: &this_type::get;
      }
      
#else 
      
      typedef T * this_type::*unspecified_bool_type;
      
      operator unspecified_bool_type() const // never throws
      {
        return px == 0? 0: &this_type::px;
      }
      
#endif
      
      // operator! is redundant, but some compilers need it
      
      bool operator! () const // never throws
      {
        return px == 0;
      }
      
      bool unique() const // never throws
      {
        return pn.unique();
      }
      
      long use_count() const // never throws
      {
        return pn.use_count();
      }
      
      void swap(shared_ptr<T> & other) // never throws
      {
        std::swap(px, other.px);
        pn.swap(other.pn);
      }
      
      template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
      {
        return pn < rhs.pn;
      }
      
      void * _internal_get_deleter(std::type_info const & ti) const
      {
        return pn.get_deleter(ti);
      }
      
      // Tasteless as this may seem, making all members public allows member templates
      // to work in the absence of member template friends. (Matthew Langston)
      
#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
      
    private:
      
      template<class Y> friend class shared_ptr;
      //    template<class Y> friend class weak_ptr; 
      
      
#endif
      
      T * px;                     // contained pointer
      ::boost::detail::shared_count pn;    // reference counter
      
    };  // shared_ptr
  
  template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
  {
    return a.get() == b.get();
  }
  
  template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
  {
    return a.get() != b.get();
  }
  
#if __GNUC__ == 2 && __GNUC_MINOR__ <= 96
  
  // Resolve the ambiguity between our op!= and the one in rel_ops
  
  template<class T> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<T> const & b)
  {
    return a.get() != b.get();
  }
  
#endif
  
  template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
  {
    return a._internal_less(b);
  }
  
  template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
  {
    a.swap(b);
  }
  
  template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
  {
    return shared_ptr<T>(r, detail::static_cast_tag());
  }
  
  template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
  {
    return shared_ptr<T>(r, detail::const_cast_tag());
  }
  
  template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
  {
    return shared_ptr<T>(r, detail::dynamic_cast_tag());
  }
  
  template<class T, class U> shared_ptr<T> static_access_down_cast(shared_ptr<U> const & r)
  {
    return shared_ptr<T>(r, detail::access_down_cast_tag());
  }
  
  // shared_*_cast names are deprecated. Use *_pointer_cast instead.
  // support for deprectated use removed
  
  
  // get_pointer() enables boost::mem_fn to recognize shared_ptr
  
  template<class T> inline T * get_pointer(shared_ptr<T> const & p)
  {
    return p.get();
  }
  
  // operator<<
  
#if defined(__GNUC__) &&  (__GNUC__ < 3)
  
  template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> const & p)
  {
    os << p.get();
    return os;
  }
  
#else
  
# if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, <= 1200 && __SGI_STL_PORT)
  // MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
  using std::basic_ostream;
  template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, shared_ptr<Y> const & p)
# else
  template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)
# endif 
  {
    os << p.get();
    return os;
  }
  
#endif
  
  // get_deleter (experimental)
  
#if ( defined(__GNUC__) && BOOST_WORKAROUND(__GNUC__, < 3) ) || \
( defined(__EDG_VERSION__) && BOOST_WORKAROUND(__EDG_VERSION__, <= 238) ) || \
( defined(__HP_aCC) && BOOST_WORKAROUND(__HP_aCC, <= 33500) )
  
  // g++ 2.9x doesn't allow static_cast<X const *>(void *)
  // apparently EDG 2.38 and HP aCC A.03.35 also don't accept it
  
  template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
  {
    void const * q = p._internal_get_deleter(typeid(D));
    return const_cast<D *>(static_cast<D const *>(q));
  }
  
#else
  
  template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
  {
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
  }
  
#endif
  
} // namespace gs

#ifdef BOOST_MSVC
# pragma warning(pop)
#endif    

#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)

#endif  // #ifndef GS_SHARED_PTR_HPP_INCLUDED
