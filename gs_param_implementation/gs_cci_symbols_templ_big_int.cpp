// LICENSETEXT
//
//   Copyright (C) 2010 : GreenSocs Ltd
// 	 http://www.greensocs.com/ , email: info@greensocs.com
//
//   Developed by:
//    Christian Schroeder <schroeder@eis.cs.tu-bs.de>,
//
//
// The contents of this file are subject to the licensing terms specified
// in the file LICENSE. Please consult this file for restrictions and
// limitations that may apply.
// 
// ENDLICENSETEXT

#include "cci_params.h"

// To be defined by makefile:
//  This make run creates only symbols for widths SYMBOLS_LOWER_BOUND to SYMBOLS_UPPER_BOUND
//  This is needed to keept the compile runs small.
// #define CCI_SYMBOLS_LOWER_BOUND 1
// #define CCI_SYMBOLS_UPPER_BOUND 10

#ifndef CCI_SYMBOLS_LOWER_BOUND
  #error "You must define bounds to be generated by this file!"
#endif
#ifndef CCI_SYMBOLS_UPPER_BOUND
  #error "You must define bounds to be generated by this file!"
#endif

//
// PART 3: Template types sc_bigint<w>, sc_biguint<w>
//
// This creates symbols for standard parameter types in this library!
//


__OPEN_NAMESPACE_EXAMPLE_PARAM_IMPLEMENTATION__

  // ***********************************************************
  // ** Create template types using template meta programming **
  // ***********************************************************

using namespace cci::cnf;
using namespace sc_dt;
  
#define PLACE_FUNCTION_POINTERS_T_TM(T,TM) \
  cci_param_impl_if<T<LOWER>, TM>*  (*call_create1_##T##TM)(cci_param<T<LOWER>, TM>*, const char*, const bool, cci_cnf_broker_if* broker_accessor); \
  cci_param_impl_if<T<LOWER>, TM>*  (*call_create2_##T##TM)(cci_param<T<LOWER>, TM>*, const char*, const T<LOWER>&, const bool, cci_cnf_broker_if* broker_accessor); \
  cci_param_impl_if<T<LOWER>, TM>*  (*call_create3_##T##TM)(cci_param<T<LOWER>, TM>*, const char*, const char*,  const bool, cci_cnf_broker_if* broker_accessor); \
  void (*call_create4_##T##TM)(cci_param<T<LOWER>, TM>*); \
  void (*call_create5_##T##TM)(cci_param<T<LOWER>, TM>*);
#define PLACE_FUNCTION_POINTERS_T(T) \
  PLACE_FUNCTION_POINTERS_T_TM(T, mutable_param) \
  PLACE_FUNCTION_POINTERS_T_TM(T, immutable_param) \
  PLACE_FUNCTION_POINTERS_T_TM(T, elaboration_time_param) \
  PLACE_FUNCTION_POINTERS_T_TM(T, other_param)

#define PLACE_FUNCTION_CALLS_T_TM(T,TM) \
  call_create1_##T##TM(&create_cci_param<T<LOWER>, TM>), \
  call_create2_##T##TM(&create_cci_param<T<LOWER>, TM>), \
  call_create3_##T##TM(&create_cci_param<T<LOWER>, TM>), \
  call_create4_##T##TM(&init_cci_param<T<LOWER>, TM>), \
  call_create5_##T##TM(&destroy_cci_param<T<LOWER>, TM>), 
#define PLACE_FUNCTION_CALLS_T(T) \
  PLACE_FUNCTION_CALLS_T_TM(T, mutable_param) \
  PLACE_FUNCTION_CALLS_T_TM(T, immutable_param) \
  PLACE_FUNCTION_CALLS_T_TM(T, elaboration_time_param) \
  PLACE_FUNCTION_CALLS_T_TM(T, other_param)


#define PLACE_BIG_FUNCTION_POINTERS() \
  PLACE_FUNCTION_POINTERS_T(sc_bigint) \
  PLACE_FUNCTION_POINTERS_T(sc_biguint)

#define PLACE_BIG_FUNCTION_CALLS() \
  PLACE_FUNCTION_CALLS_T(sc_bigint) \
  PLACE_FUNCTION_CALLS_T(sc_biguint)


  template <int LOWER, int UPPER, bool CONT>
  struct looper_sc_big_u_int
  { 
  };

  template <int LOWER, int UPPER> 
  struct looper_sc_big_u_int<LOWER, UPPER, false> 
  { 
    PLACE_BIG_FUNCTION_POINTERS()
    looper_sc_big_u_int() : PLACE_BIG_FUNCTION_CALLS() i(0)
    {}
    int i;
  }; 

  template <int LOWER, int UPPER> 
  struct looper_sc_big_u_int<LOWER, UPPER, true> 
  : looper_sc_big_u_int<LOWER+1,UPPER,((LOWER+1)<UPPER) > 
  { 
    PLACE_BIG_FUNCTION_POINTERS()
    looper_sc_big_u_int() : PLACE_BIG_FUNCTION_CALLS() i(0)
    {}
    int i; 
  };

  // Maximum recursion depth allowed is 500, so split up!
  // use several object files to keep the compile "small"
  template 
  struct looper_sc_big_u_int<CCI_SYMBOLS_LOWER_BOUND,CCI_SYMBOLS_UPPER_BOUND,true>;
  
  
__CLOSE_NAMESPACE_EXAMPLE_PARAM_IMPLEMENTATION__  

